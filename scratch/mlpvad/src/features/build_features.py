"""
This module provides a way to get the data from the raw directory and present it
as features for entry into the models. Its main API is the generate_data function.
"""
import audiosegment
import enum

class ClassLabels(enum.Enum):
    NO_VOICE = 0
    VOICE = 1

def _generate_segments(data_dir, sampling_frequency_hz=32000, sample_width=2, channels=1):
    """
    Generator function for creating a single audiosegment.AudioSegment object per wav file at a time
    from the raw data.

    :param data_dir: The top-level directory to walk down from, searching for wav files along the way.
    :param sampling_frequency_hz: Each wav file will be resampled to this frequency (if it isn't already at this one).
    :param sample_width: Each wav file will be resampled to this number of bytes per sample (if it isn't already at this one).
    :param channels: Each wav file will be resampled to this number of channels (if it isn't already at this one).
    :returns: Yields a single wav file at a time, as a segment.
    """
    for root, dirs, wavpath in os.walk(data_dir):
        seg = audiosegment.from_file(os.join([root, wavpath]))
        if seg.frame_rate != sampling_frequency_hz or seg.sample_width != sample_width or seg.channels != channels:
            seg = seg.resample(sample_rate_Hz=sampling_frequency_hz, sample_width=sample_width, channels=channels)
        yield seg

def calculate_steps_per_epoch(data_dir, samples_per_vector=1024, batch_size=32, sampling_frequency_hz=32000, channels=1):
    """
    Figures out how many steps there are in an epoch. Simply number of samples in the dataset / batch_size.

    This will take a while to calculate, so once it is determined, it may make sense to store it and reuse it
    (assuming your data doesn't change between training runs).

    The calculation is this:
    steps_per_epoch = int(num_samples_in_dataset / samples_per_batch)

    Where:

    samples_per_batch = samples_per_vector * batch_size
    num_samples_in_dataset = SUM over all wav files { samples in wav file }
    samples_in_wav_file_i = len_in_seconds * sampling_frequency_hz * channels

    In order to calculate the number of steps, all of the following parameters must be known.

    :param data_dir: The top-level directory to walk down from, searching for wav files along the way.
    :param samples_per_vector: The number of samples in a single vector.
    :param batch_size: The number of vectors in a batch.
    :param sampling_frequency_hz: The frequency with which the wav files will be sampled.
    :param channels: The number of channels in a wav file.
    :returns: The number of vectors in the entire dataset.
    """
    num_samples_in_dataset = sum((len(seg) for seg in _generate_segments(sampling_frequency_hz=sampling_frequency_hz, channels=channels)))
    samples_per_batch = samples_per_vector * batch_size
    steps_per_epoch = int(num_samples_in_dataset / samples_per_batch)
    return steps_per_epoch

def generate_data(data_dir, samples_per_vector=1024, batch_size=32, sampling_frequency_hz=32000, sample_width=2, channels=1):
    """
    Generates tuples of the form (input_vectors, class_label) indefinitely.

    The input_vectors that are generated by this function are simply samples_per_vector samples taken sequentially from
    wav files at random (without replacement until all wav files are used).

    So the general steps are this:
    - Get a wav file from the data repository along with its label.
    - Resample the file to the given properties (does not alter the original file).
    - Until the resampled file has run out of samples, read out samples_per_vector samples from it sequentially
      and pack them up into a vector. Do this batch_size number of times to create a batch.
    - If the wav file ran out before we got a full batch, start over from the beginning, but append the vectors
      to the batch we started.
    - Return the batch along with the labels.

    :param data_dir: The top-level directory to walk down from, searching for wav files along the way.
    :param samples_per_vector: The size of the input_vector.
    :param batch_size: The number of vectors in a batch.
    :param sampling_frequency: The raw wav file will be read in and resampled to this frequency.
    :param sample_width: The raw wav file will be read in and resampled using this number of bytes per sample.
    :param channels: The raw wav file will be read in and resampled to this number of channels.
    :returns: Tuple of the form (input_vector, class_label)
    """
    # TODO
    pass
